# OAuth PKCE Flow Architecture

This document describes the complete OAuth 2.0 PKCE flow for the SFLT application, including all components and their interactions.

## Architecture Overview

```
Browser -> CloudFront -> Lambda@Edge -> S3 (React App)
                    |
                    v
              AWS Cognito (OAuth Provider)
                    |
                    v
              Google OAuth (Identity Provider)
```

## Components

### 1. **Lambda@Edge** (`cdk/lambda-edge/auth_handler.py`)
- **Purpose**: Route protection and OAuth flow initiation
- **Location**: CloudFront edge locations (us-east-1 deployed, globally distributed)
- **Event**: `viewer-request` - intercepts ALL requests before they reach S3

### 2. **React App** (`frontend/src/`)
- **Purpose**: User interface and client-side OAuth handling
- **Location**: S3 bucket served via CloudFront
- **Key Files**:
  - `src/App.jsx` - Main app component with auth state
  - `src/components/AuthButton.jsx` - OAuth login/logout UI
  - `src/aws-exports.js` - Generated Cognito configuration

### 3. **AWS Cognito**
- **Purpose**: OAuth 2.0 Authorization Server
- **Components**:
  - User Pool: `ap-southeast-2_u6zH1Pbty`
  - Client: `2chnp95qkugngcet88uiokikpm` (PKCE enabled)
  - Hosted UI: `sflt-auth.auth.ap-southeast-2.amazoncognito.com`

### 4. **Google OAuth**
- **Purpose**: Identity Provider (IdP)
- **Integration**: Federated with Cognito User Pool

## OAuth PKCE Flow Steps

### **Step 1: User Accesses Protected Route**
```
User -> https://d3nteozhns257o.cloudfront.net/admin
```

**Current Flow (BROKEN):**
1. CloudFront receives request
2. Lambda@Edge intercepts at viewer-request
3. Checks if `/admin` is protected â†’ YES
4. Checks for JWT token in cookies â†’ NOT FOUND
5. **âŒ Returns 401 Unauthorized with text/plain body**
6. Browser shows "Unauthorized: Authentication required"
7. **âŒ React app never loads!**

**Correct Flow Should Be:**
1. CloudFront receives request
2. Lambda@Edge intercepts at viewer-request
3. Checks if `/admin` is protected â†’ YES
4. Checks for JWT token in cookies â†’ NOT FOUND
5. **âœ… Redirects to Cognito Hosted UI for OAuth login**
6. User completes OAuth flow
7. Returns to `/admin` with tokens
8. Lambda@Edge validates tokens and serves React app

### **Step 2: OAuth Authorization (Cognito Hosted UI)**
```
Browser -> https://sflt-auth.auth.ap-southeast-2.amazoncognito.com/login
```

**Parameters:**
- `client_id`: `2chnp95qkugngcet88uiokikpm`
- `response_type`: `code`
- `scope`: `email openid profile`
- `redirect_uri`: `https://d3nteozhns257o.cloudfront.net/`
- `state`: `{"target": "/admin"}` (URL encoded)
- `code_challenge`: Generated by client (PKCE)
- `code_challenge_method`: `S256`

**Process:**
1. User sees Cognito login page
2. User clicks "Sign in with Google"
3. Redirected to Google OAuth
4. User authenticates with Google
5. Google returns to Cognito with authorization code
6. Cognito processes Google response
7. Cognito redirects back to `redirect_uri` with authorization code

### **Step 3: Authorization Code Exchange**
```
Browser -> https://d3nteozhns257o.cloudfront.net/?code=xyz&state=...
```

**What Should Happen:**
1. Lambda@Edge sees the `code` parameter
2. **Option A**: Lambda@Edge exchanges code for tokens server-side
3. **Option B**: Lambda@Edge serves React app, React handles token exchange client-side

**Current State**: Neither option is implemented properly!

### **Step 4: Token Storage and Validation**
**Tokens Received:**
- `id_token`: JWT with user identity claims
- `access_token`: OAuth access token
- `refresh_token`: For token renewal

**Storage Options:**
- **HttpOnly Cookies**: Secure, protected from XSS
- **LocalStorage**: Accessible to JavaScript, vulnerable to XSS
- **SessionStorage**: Temporary, cleared on browser close

### **Step 5: Protected Route Access**
```
Browser -> https://d3nteozhns257o.cloudfront.net/admin (with tokens)
```

**Correct Flow:**
1. Lambda@Edge intercepts request
2. Extracts JWT from cookies
3. Validates JWT signature and claims
4. If valid â†’ serves React app (`/index.html`)
5. React app loads and handles client-side routing to `/admin`

## Current Issues

### **ðŸš¨ Critical Problem: No React App Loading**
The current Lambda@Edge logic returns 401 for protected routes without tokens, but this prevents the React app from ever loading. Users see a plain text error instead of the login interface.

### **ðŸš¨ Missing Token Exchange Logic**
There's no code to handle the OAuth callback with the authorization code and exchange it for tokens.

### **ðŸš¨ No Token Storage Strategy**
No mechanism to store and retrieve tokens securely.

## Proposed Architecture Fix

### **Lambda@Edge Strategy: Smart Redirects**
```python
def handler(event, context):
    request = event["Records"][0]["cf"]["request"]
    uri = request["uri"]
    headers = request.get("headers", {})
    
    # Check if this is an OAuth callback
    if uri == "/" and "code" in request.get("querystring", ""):
        # This is OAuth callback - serve React app to handle token exchange
        request["uri"] = "/index.html"
        return request
    
    # Check if this is a protected route
    if is_protected_route(uri):
        # Extract JWT token from cookies
        token = extract_token_from_cookie(headers.get("cookie", [{}])[0].get("value", ""))
        
        if not token:
            # No token - redirect to OAuth login
            return create_login_redirect(uri, headers["host"][0]["value"])
        
        # Validate token
        if not is_jwt_valid(token):
            # Invalid token - redirect to OAuth login
            return create_login_redirect(uri, headers["host"][0]["value"])
        
        # Valid token - serve React app
        request["uri"] = "/index.html"
        return request
    
    # Non-protected route - handle SPA routing
    if uri != "/" and "." not in uri.split("/")[-1]:
        request["uri"] = "/index.html"
    
    return request
```

### **React App Strategy: Client-Side OAuth**
```javascript
// src/components/AuthManager.jsx
export const AuthManager = () => {
  useEffect(() => {
    // Check for OAuth callback
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const state = urlParams.get('state');
    
    if (code && state) {
      // Exchange authorization code for tokens
      exchangeCodeForTokens(code, state);
    }
  }, []);
};

// src/services/authService.js
export const exchangeCodeForTokens = async (code, state) => {
  // PKCE token exchange with Cognito
  const response = await fetch('https://sflt-auth.auth.ap-southeast-2.amazoncognito.com/oauth2/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      client_id: '2chnp95qkugngcet88uiokikpm',
      code: code,
      redirect_uri: window.location.origin + '/',
      code_verifier: getStoredCodeVerifier()
    })
  });
  
  const tokens = await response.json();
  storeTokens(tokens);
  
  // Redirect to original target
  const targetUrl = JSON.parse(decodeURIComponent(state)).target;
  window.location.href = targetUrl;
};
```

## File Responsibilities

### **Lambda@Edge Files**
- `cdk/lambda-edge/auth_handler.py` - Route protection and OAuth redirects
- `cdk/lambda-edge/auth_handler.py.template` - Template for dynamic values

### **React App Files**
- `frontend/src/App.jsx` - Main app with auth state management
- `frontend/src/components/AuthButton.jsx` - Login/logout UI
- `frontend/src/components/AuthManager.jsx` - OAuth callback handling
- `frontend/src/services/authService.js` - Token exchange and storage
- `frontend/src/aws-exports.js` - Generated Cognito configuration

### **Infrastructure Files**
- `cdk/static_site_stack.py` - CloudFront + Lambda@Edge setup
- `scripts/generate_lambda_code.py` - Template processing
- `scripts/generate_aws_exports.py` - Frontend config generation

## Security Considerations

### **PKCE Implementation**
- **Code Verifier**: Random string generated client-side
- **Code Challenge**: SHA256 hash of verifier
- **Storage**: Code verifier stored in sessionStorage during OAuth flow

### **Token Storage**
- **Recommendation**: HttpOnly cookies for security
- **Alternative**: Secure localStorage with XSS protection
- **Expiration**: Automatic cleanup of expired tokens

### **JWT Validation**
- **Signature**: Verify against Cognito public keys
- **Claims**: Validate `iss`, `aud`, `exp`, `token_use`
- **Scope**: Ensure required permissions

## Next Steps

1. **Fix Lambda@Edge Logic**: Implement smart redirects instead of 401 responses
2. **Add OAuth Callback Handling**: Process authorization codes
3. **Implement Token Exchange**: Client-side PKCE flow completion
4. **Add Token Storage**: Secure cookie-based token management
5. **Enhance JWT Validation**: Full signature verification
6. **Add Token Refresh**: Automatic token renewal

## Testing Strategy

### **Manual Testing Steps**
1. Access protected route: `https://d3nteozhns257o.cloudfront.net/admin`
2. Should redirect to: `https://sflt-auth.auth.ap-southeast-2.amazoncognito.com/login`
3. Login with Google
4. Should redirect back to: `https://d3nteozhns257o.cloudfront.net/?code=...`
5. React app should exchange code for tokens
6. Should redirect to: `https://d3nteozhns257o.cloudfront.net/admin`
7. Should display protected content

### **Automated Testing**
- E2E tests with Playwright
- JWT validation unit tests
- OAuth flow simulation tests